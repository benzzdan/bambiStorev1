(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["ReactHistory"] = factory(require("react"));
	else
		root["ReactHistory"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.ControlledMemoryRouter = exports.ControlledBrowserRouter = exports.ControlledHistory = undefined;

	var _ControlledHistory2 = __webpack_require__(1);

	var _ControlledHistory3 = _interopRequireDefault(_ControlledHistory2);

	var _ControlledBrowserRouter2 = __webpack_require__(6);

	var _ControlledBrowserRouter3 = _interopRequireDefault(_ControlledBrowserRouter2);

	var _ControlledMemoryRouter2 = __webpack_require__(19);

	var _ControlledMemoryRouter3 = _interopRequireDefault(_ControlledMemoryRouter2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.ControlledHistory = _ControlledHistory3.default;
	exports.ControlledBrowserRouter = _ControlledBrowserRouter3.default;
	exports.ControlledMemoryRouter = _ControlledMemoryRouter3.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _LocationUtils = __webpack_require__(3);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var initialKeys = [undefined];

	var ControlledHistory = function (_React$Component) {
	  _inherits(ControlledHistory, _React$Component);

	  ControlledHistory.prototype.getChildContext = function getChildContext() {
	    return {
	      history: this.props.history
	    };
	  };

	  function ControlledHistory(props) {
	    _classCallCheck(this, ControlledHistory);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    var location = props.history.location;
	    var shouldRestoreKeys = !!location.key;
	    _this.updatingFromHistoryChange = false;
	    _this.syncingHistory = false;
	    _this.keys = shouldRestoreKeys ? props.restoreKeys() || initialKeys : initialKeys;
	    _this.setupHistory();
	    _this.state = {
	      location: location,
	      action: 'POP'
	    };
	    return _this;
	  }

	  // TODO: We need to do this to give them the right location, or require
	  // them to create their own history... I dunno yet.
	  //componentDidMount() {
	  //this.props.onChange(this.state.location, 'SYNC')
	  //}

	  ControlledHistory.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    if (!this.syncingHistory && !this.updatingFromHistoryChange && !(0, _LocationUtils.locationsAreEqual)(nextProps.location, this.props.location)) {
	      this.syncingHistory = true;
	      var history = this.props.history;
	      var action = nextProps.action;
	      var location = nextProps.location;

	      var nextIndex = this.keys.indexOf(location.key);
	      if (location.key && nextIndex !== -1) {
	        // we've been here before
	        var currentIndex = this.keys.indexOf(this.props.location.key);
	        var delta = nextIndex - currentIndex;
	        history.go(delta);
	      } else if (action === 'PUSH') {
	        history.push(location);
	      } else if (action === 'REPLACE') {
	        history.replace(location);
	      }
	    }
	  };

	  ControlledHistory.prototype.setupHistory = function setupHistory() {
	    var _this2 = this;

	    this.props.history.listen(function (location, action) {
	      _this2.storeKey(location.key, action);
	      _this2.updatingFromHistoryChange = true; // must come before onChange!
	      if (_this2.syncingHistory) {
	        _this2.props.onChange(location, 'SYNC');
	      } else {
	        _this2.props.onChange(location, action);
	      }
	      _this2.setState({ location: location, action: action }, function () {
	        _this2.updatingFromHistoryChange = false;
	        if (_this2.syncingHistory) {
	          _this2.syncingHistory = false;
	        } else {
	          _this2.checkIfLocationAccepted();
	        }
	      });
	    });
	  };

	  ControlledHistory.prototype.checkIfLocationAccepted = function checkIfLocationAccepted() {
	    var location = this.props.location;
	    var _state = this.state;
	    var stateLocation = _state.location;
	    var stateAction = _state.action;

	    if (!(0, _LocationUtils.locationsAreEqual)(location, stateLocation)) {
	      this.syncingHistory = true;
	      var index = this.keys.indexOf(location.key);
	      var stateIndex = this.keys.indexOf(stateLocation.key);
	      var delta = index - stateIndex;
	      if (stateAction === 'REPLACE') {
	        this.props.history.replace(location);
	      } else {
	        if (stateIndex === -1) {
	          // playing whack-a-mole here D: after we pop off the last key a
	          // few lines down, if they click "forward" we won't find the key
	          // so let's just do a -1 for delta.
	          this.props.history.go(-1);
	        } else {
	          this.props.history.go(delta);
	        }
	        if (stateAction === 'PUSH') {
	          // get rid of the last entry so our delta isn't off if they try to
	          // push here again
	          this.keys.pop();
	        }
	      }
	    }
	  };

	  ControlledHistory.prototype.storeKey = function storeKey(key, action) {
	    if (action === 'PUSH') {
	      this.keys.push(key);
	    } else if (action === 'REPLACE') {
	      this.keys[this.keys.length - 1] = key;
	    }
	    // browsers only keep 50 entries, so we'll do that too
	    if (this.keys.length > 50) this.keys.unshift();
	    this.props.saveKeys(this.keys);
	  };

	  ControlledHistory.prototype.render = function render() {
	    var _props = this.props;
	    var history = _props.history;
	    var location = _props.location;
	    var action = _props.action;

	    return this.props.children({
	      history: history,
	      location: location,
	      action: action
	    });
	  };

	  return ControlledHistory;
	}(_react2.default.Component);

	ControlledHistory.propTypes = {
	  children: _react.PropTypes.func.isRequired,
	  history: _react.PropTypes.object.isRequired,
	  location: _react.PropTypes.object.isRequired,
	  action: _react.PropTypes.string.isRequired,
	  onChange: _react.PropTypes.func.isRequired,
	  restoreKeys: _react.PropTypes.func.isRequired,
	  saveKeys: _react.PropTypes.func.isRequired
	};
	ControlledHistory.childContextTypes = {
	  history: _react.PropTypes.object.isRequired
	};
	ControlledHistory.defaultProps = {
	  restoreKeys: function restoreKeys() {
	    return initialKeys;
	  },
	  saveKeys: function saveKeys() {}
	};
	exports.default = ControlledHistory;

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.locationsAreEqual = exports.createLocation = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _resolvePathname = __webpack_require__(4);

	var _resolvePathname2 = _interopRequireDefault(_resolvePathname);

	var _PathUtils = __webpack_require__(5);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {
	  var location = void 0;
	  if (typeof path === 'string') {
	    // Two-arg form: push(path, state)
	    location = (0, _PathUtils.parsePath)(path);
	    location.state = state;
	  } else {
	    // One-arg form: push(location)
	    location = _extends({}, path);

	    if (location.pathname === undefined) location.pathname = '';

	    if (location.search) {
	      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
	    } else {
	      location.search = '';
	    }

	    if (location.hash) {
	      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
	    } else {
	      location.hash = '';
	    }

	    if (state !== undefined && location.state === undefined) location.state = state;
	  }

	  location.key = key;

	  if (currentLocation) {
	    // Resolve incomplete/relative pathname relative to current location.
	    if (!location.pathname) {
	      location.pathname = currentLocation.pathname;
	    } else if (location.pathname.charAt(0) !== '/') {
	      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
	    }
	  }

	  return location;
	};

	var looseEqual = function looseEqual(a, b) {
	  if (a == null) return a == b;

	  var typeofA = typeof a === 'undefined' ? 'undefined' : _typeof(a);
	  var typeofB = typeof b === 'undefined' ? 'undefined' : _typeof(b);

	  if (typeofA !== typeofB) return false;

	  if (Array.isArray(a)) {
	    if (!Array.isArray(b) || a.length !== b.length) return false;

	    return a.every(function (item, index) {
	      return looseEqual(item, b[index]);
	    });
	  } else if (typeofA === 'object') {
	    var aKeys = Object.keys(a);
	    var bKeys = Object.keys(b);

	    if (aKeys.length !== bKeys.length) return false;

	    return aKeys.every(function (key) {
	      return looseEqual(a[key], b[key]);
	    });
	  }

	  return a === b;
	};

	var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
	  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && looseEqual(a.state, b.state);
	};

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';

	var isAbsolute = function isAbsolute(pathname) {
	  return pathname.charAt(0) === '/';
	};

	// About 1.5x faster than the two-arg version of Array#splice()
	var spliceOne = function spliceOne(list, index) {
	  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
	    list[i] = list[k];
	  }list.pop();
	};

	// This implementation is based heavily on node's url.parse
	var resolvePathname = function resolvePathname(to) {
	  var from = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	  var toParts = to && to.split('/') || [];
	  var fromParts = from && from.split('/') || [];

	  var isToAbs = to && isAbsolute(to);
	  var isFromAbs = from && isAbsolute(from);
	  var mustEndAbs = isToAbs || isFromAbs;

	  if (to && isAbsolute(to)) {
	    // to is absolute
	    fromParts = toParts;
	  } else if (toParts.length) {
	    // to is relative, drop the filename
	    fromParts.pop();
	    fromParts = fromParts.concat(toParts);
	  }

	  if (!fromParts.length) return '/';

	  var hasTrailingSlash = void 0;
	  if (fromParts.length) {
	    var last = fromParts[fromParts.length - 1];
	    hasTrailingSlash = last === '.' || last === '..' || last === '';
	  } else {
	    hasTrailingSlash = false;
	  }

	  var up = 0;
	  for (var i = fromParts.length; i >= 0; i--) {
	    var part = fromParts[i];

	    if (part === '.') {
	      spliceOne(fromParts, i);
	    } else if (part === '..') {
	      spliceOne(fromParts, i);
	      up++;
	    } else if (up) {
	      spliceOne(fromParts, i);
	      up--;
	    }
	  }

	  if (!mustEndAbs) for (; up--; up) {
	    fromParts.unshift('..');
	  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

	  var result = fromParts.join('/');

	  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

	  return result;
	};

	module.exports = resolvePathname;

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	var addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {
	  return path.charAt(0) === '/' ? path : '/' + path;
	};

	var stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {
	  return path.charAt(0) === '/' ? path.substr(1) : path;
	};

	var stripPrefix = exports.stripPrefix = function stripPrefix(path, prefix) {
	  return path.indexOf(prefix) === 0 ? path.substr(prefix.length) : path;
	};

	var parsePath = exports.parsePath = function parsePath(path) {
	  var pathname = path || '/';
	  var search = '';
	  var hash = '';

	  var hashIndex = pathname.indexOf('#');
	  if (hashIndex !== -1) {
	    hash = pathname.substr(hashIndex);
	    pathname = pathname.substr(0, hashIndex);
	  }

	  var searchIndex = pathname.indexOf('?');
	  if (searchIndex !== -1) {
	    search = pathname.substr(searchIndex);
	    pathname = pathname.substr(0, searchIndex);
	  }

	  return {
	    pathname: pathname,
	    search: search === '?' ? '' : search,
	    hash: hash === '#' ? '' : hash
	  };
	};

	var createPath = exports.createPath = function createPath(location) {
	  var pathname = location.pathname;
	  var search = location.search;
	  var hash = location.hash;


	  var path = pathname || '/';

	  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

	  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

	  return path;
	};

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _ControlledHistory = __webpack_require__(1);

	var _ControlledHistory2 = _interopRequireDefault(_ControlledHistory);

	var _StaticRouter = __webpack_require__(7);

	var _StaticRouter2 = _interopRequireDefault(_StaticRouter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	var restoreKeys = function restoreKeys() {
	  try {
	    return JSON.parse(sessionStorage.ReactRouterKeys);
	  } catch (e) {} // eslint-disable-line
	};

	var saveKeys = function saveKeys(keys) {
	  try {
	    sessionStorage.ReactRouterKeys = JSON.stringify(keys);
	  } catch (e) {} // eslint-disable-line
	};

	var ControlledBrowserRouter = function ControlledBrowserRouter(_ref) {
	  var history = _ref.history;
	  var location = _ref.location;
	  var action = _ref.action;
	  var onChange = _ref.onChange;
	  var basename = _ref.basename;

	  var routerProps = _objectWithoutProperties(_ref, ['history', 'location', 'action', 'onChange', 'basename']);

	  return _react2.default.createElement(
	    _ControlledHistory2.default,
	    {
	      history: history,
	      location: location,
	      action: action,
	      onChange: onChange,
	      restoreKeys: restoreKeys,
	      saveKeys: saveKeys
	    },
	    function (_ref2) {
	      var history = _ref2.history;
	      var action = _ref2.action;
	      var location = _ref2.location;
	      return _react2.default.createElement(_StaticRouter2.default, _extends({
	        action: action,
	        location: location,
	        basename: basename,
	        onPush: history.push,
	        onReplace: history.replace,
	        blockTransitions: history.block
	      }, routerProps));
	    }
	  );
	};

	ControlledBrowserRouter.propTypes = {
	  history: _react.PropTypes.object,
	  location: _react.PropTypes.object,
	  action: _react.PropTypes.string,
	  onChange: _react.PropTypes.func,
	  basename: _react.PropTypes.string,
	  children: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.node])
	};

	exports.default = ControlledBrowserRouter;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _queryString = __webpack_require__(8);

	var _MatchProvider = __webpack_require__(11);

	var _MatchProvider2 = _interopRequireDefault(_MatchProvider);

	var _Broadcasts = __webpack_require__(13);

	var _LocationUtils = __webpack_require__(18);

	var _PropTypes = __webpack_require__(12);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var stringifyQuery = function stringifyQuery(query) {
	  return (0, _queryString.stringify)(query).replace(/%20/g, '+');
	};

	var StaticRouter = function (_React$Component) {
	  _inherits(StaticRouter, _React$Component);

	  function StaticRouter() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, StaticRouter);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.transitionTo = function (location) {
	      _this.props.onPush(_this.createLocation(location));
	    }, _this.replaceWith = function (location) {
	      _this.props.onReplace(_this.createLocation(location));
	    }, _this.blockTransitions = function (prompt) {
	      return _this.props.blockTransitions(prompt);
	    }, _this.createHref = function (to) {
	      var path = (0, _LocationUtils.createRouterPath)(to, _this.props.stringifyQuery);

	      if (_this.props.basename) if (path === '/') path = _this.props.basename;else if (path.length >= 2 && path.charAt(0) === '/' && path.charAt(1) === '?') path = _this.props.basename + path.substring(1);else path = _this.props.basename + path;

	      return _this.props.createHref(path);
	    }, _this.state = {
	      location: null
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  StaticRouter.prototype.createLocation = function createLocation(location) {
	    var _props = this.props;
	    var parseQueryString = _props.parseQueryString;
	    var stringifyQuery = _props.stringifyQuery;

	    return (0, _LocationUtils.createRouterLocation)(location, parseQueryString, stringifyQuery);
	  };

	  StaticRouter.prototype.getRouterContext = function getRouterContext() {
	    return {
	      transitionTo: this.transitionTo,
	      replaceWith: this.replaceWith,
	      blockTransitions: this.blockTransitions,
	      createHref: this.createHref
	    };
	  };

	  StaticRouter.prototype.getChildContext = function getChildContext() {
	    return {
	      router: this.getRouterContext()
	    };
	  };

	  StaticRouter.prototype.componentWillMount = function componentWillMount() {
	    this.setState({
	      location: this.createLocation(this.props.location)
	    });
	  };

	  StaticRouter.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    var nextLocation = this.createLocation(nextProps.location);

	    if (!(0, _LocationUtils.locationsAreEqual)(this.state.location, nextLocation)) this.setState({ location: nextLocation });
	  };

	  StaticRouter.prototype.render = function render() {
	    var location = this.state.location;
	    var _props2 = this.props;
	    var action = _props2.action;
	    var children = _props2.children;


	    return _react2.default.createElement(
	      _Broadcasts.LocationBroadcast,
	      { value: location },
	      _react2.default.createElement(
	        _MatchProvider2.default,
	        null,
	        typeof children === 'function' ? children({ action: action, location: location, router: this.getRouterContext() }) : _react2.default.Children.only(children)
	      )
	    );
	  };

	  return StaticRouter;
	}(_react2.default.Component);

	StaticRouter.defaultProps = {
	  stringifyQuery: stringifyQuery,
	  parseQueryString: _queryString.parse,
	  createHref: function createHref(path) {
	    return path;
	  }
	};
	StaticRouter.childContextTypes = {
	  router: _PropTypes.routerContext.isRequired
	};


	if (false) {
	  StaticRouter.propTypes = {
	    children: _react.PropTypes.oneOfType([_react.PropTypes.node, _react.PropTypes.func]),

	    action: _PropTypes.action.isRequired,
	    location: _react.PropTypes.oneOfType([_react.PropTypes.object, _react.PropTypes.string]).isRequired,

	    onPush: _react.PropTypes.func.isRequired,
	    onReplace: _react.PropTypes.func.isRequired,
	    blockTransitions: _react.PropTypes.func,

	    stringifyQuery: _react.PropTypes.func.isRequired,
	    parseQueryString: _react.PropTypes.func.isRequired,
	    createHref: _react.PropTypes.func.isRequired, // TODO: Clarify why this is useful

	    basename: _react.PropTypes.string // TODO: Feels like we should be able to remove this
	  };
	}

	exports.default = StaticRouter;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strictUriEncode = __webpack_require__(9);
	var objectAssign = __webpack_require__(10);

	function encode(value, opts) {
		if (opts.encode) {
			return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
		}

		return value;
	}

	exports.extract = function (str) {
		return str.split('?')[1] || '';
	};

	exports.parse = function (str) {
		// Create an object with no prototype
		// https://github.com/sindresorhus/query-string/issues/47
		var ret = Object.create(null);

		if (typeof str !== 'string') {
			return ret;
		}

		str = str.trim().replace(/^(\?|#|&)/, '');

		if (!str) {
			return ret;
		}

		str.split('&').forEach(function (param) {
			var parts = param.replace(/\+/g, ' ').split('=');
			// Firefox (pre 40) decodes `%3D` to `=`
			// https://github.com/sindresorhus/query-string/pull/37
			var key = parts.shift();
			var val = parts.length > 0 ? parts.join('=') : undefined;

			key = decodeURIComponent(key);

			// missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			val = val === undefined ? null : decodeURIComponent(val);

			if (ret[key] === undefined) {
				ret[key] = val;
			} else if (Array.isArray(ret[key])) {
				ret[key].push(val);
			} else {
				ret[key] = [ret[key], val];
			}
		});

		return ret;
	};

	exports.stringify = function (obj, opts) {
		var defaults = {
			encode: true,
			strict: true
		};

		opts = objectAssign(defaults, opts);

		return obj ? Object.keys(obj).sort().map(function (key) {
			var val = obj[key];

			if (val === undefined) {
				return '';
			}

			if (val === null) {
				return encode(key, opts);
			}

			if (Array.isArray(val)) {
				var result = [];

				val.slice().forEach(function (val2) {
					if (val2 === undefined) {
						return;
					}

					if (val2 === null) {
						result.push(encode(key, opts));
					} else {
						result.push(encode(key, opts) + '=' + encode(val2, opts));
					}
				});

				return result.join('&');
			}

			return encode(key, opts) + '=' + encode(val, opts);
		}).filter(function (x) {
			return x.length > 0;
		}).join('&') : '';
	};


/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function (str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
			return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		});
	};


/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict';
	/* eslint-disable no-unused-vars */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _PropTypes = __webpack_require__(12);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var MatchProvider = function (_React$Component) {
	  _inherits(MatchProvider, _React$Component);

	  function MatchProvider(props) {
	    _classCallCheck(this, MatchProvider);

	    // **IMPORTANT** we must mutate matches, never reassign, in order for
	    // server rendering to work w/ the two-pass render approach for Miss
	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    _this.addMatch = function (match) {
	      _this.matches.push(match);
	    };

	    _this.removeMatch = function (match) {
	      _this.matches.splice(_this.matches.indexOf(match), 1);
	    };

	    _this.matches = [];
	    _this.subscribers = [];
	    _this.hasMatches = null; // use null for initial value
	    _this.serverRouterIndex = null;
	    return _this;
	  }

	  MatchProvider.prototype.getChildContext = function getChildContext() {
	    var _this2 = this;

	    return {
	      match: {
	        addMatch: this.addMatch,
	        removeMatch: this.removeMatch,
	        matches: this.matches,
	        parent: this.props.match,
	        serverRouterIndex: this.serverRouterIndex,
	        subscribe: function subscribe(fn) {
	          _this2.subscribers.push(fn);
	          return function () {
	            _this2.subscribers.splice(_this2.subscribers.indexOf(fn), 1);
	          };
	        }
	      }
	    };
	  };

	  MatchProvider.prototype.componentDidUpdate = function componentDidUpdate() {
	    this.notifySubscribers();
	  };

	  MatchProvider.prototype.componentWillMount = function componentWillMount() {
	    var serverRouter = this.context.serverRouter;

	    if (serverRouter) {
	      this.serverRouterIndex = serverRouter.registerMatchContext(this.matches);
	    }
	  };

	  MatchProvider.prototype.componentDidMount = function componentDidMount() {
	    this.notifySubscribers();
	  };

	  MatchProvider.prototype.notifySubscribers = function notifySubscribers() {
	    var _this3 = this;

	    // React's contract is that cDM of descendants is called before cDM of
	    // ancestors, so here we can safely check if we found a match
	    if (this.subscribers.length) {
	      this.hasMatches = this.matches.length !== 0;
	      this.subscribers.forEach(function (fn) {
	        return fn(_this3.hasMatches);
	      });
	    }
	  };

	  MatchProvider.prototype.render = function render() {
	    return this.props.children;
	  };

	  return MatchProvider;
	}(_react2.default.Component);

	MatchProvider.childContextTypes = {
	  match: _PropTypes.matchContext.isRequired
	};
	MatchProvider.contextTypes = {
	  serverRouter: _react.PropTypes.object
	};


	if (false) {
	  MatchProvider.propTypes = {
	    match: _react.PropTypes.any,
	    children: _react.PropTypes.node
	  };
	}

	exports.default = MatchProvider;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.routerContext = exports.historyContext = exports.location = exports.history = exports.matchContext = exports.action = undefined;

	var _react = __webpack_require__(2);

	var action = exports.action = _react.PropTypes.oneOf(['PUSH', 'REPLACE', 'POP']);

	var matchContext = exports.matchContext = _react.PropTypes.shape({
	  addMatch: _react.PropTypes.func.isRequired,
	  removeMatch: _react.PropTypes.func.isRequired
	});

	var history = exports.history = _react.PropTypes.shape({
	  listen: _react.PropTypes.func.isRequired,
	  listenBefore: _react.PropTypes.func.isRequired,
	  push: _react.PropTypes.func.isRequired,
	  replace: _react.PropTypes.func.isRequired,
	  go: _react.PropTypes.func.isRequired
	});

	var location = exports.location = _react.PropTypes.shape({
	  pathname: _react.PropTypes.string.isRequired,
	  search: _react.PropTypes.string.isRequired,
	  hash: _react.PropTypes.string.isRequired,
	  state: _react.PropTypes.any,
	  key: _react.PropTypes.string
	});

	var historyContext = exports.historyContext = _react.PropTypes.shape({
	  action: action.isRequired,
	  location: location.isRequired,
	  push: _react.PropTypes.func.isRequired,
	  replace: _react.PropTypes.func.isRequired,
	  go: _react.PropTypes.func.isRequired,
	  goBack: _react.PropTypes.func.isRequired,
	  goForward: _react.PropTypes.func.isRequired,
	  canGo: _react.PropTypes.func,
	  block: _react.PropTypes.func.isRequired
	});

	var routerContext = exports.routerContext = _react.PropTypes.shape({
	  transitionTo: _react.PropTypes.func.isRequired,
	  replaceWith: _react.PropTypes.func.isRequired,
	  blockTransitions: _react.PropTypes.func.isRequired,
	  createHref: _react.PropTypes.func.isRequired
	});

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.LocationSubscriber = exports.LocationBroadcast = undefined;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _reactBroadcast = __webpack_require__(14);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var LocationChannel = 'location';

	var LocationBroadcast = exports.LocationBroadcast = function LocationBroadcast(props) {
	  return _react2.default.createElement(_reactBroadcast.Broadcast, _extends({}, props, { channel: LocationChannel }));
	};

	var LocationSubscriber = exports.LocationSubscriber = function LocationSubscriber(props) {
	  return _react2.default.createElement(_reactBroadcast.Subscriber, _extends({}, props, { channel: LocationChannel }));
	};

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.Subscriber = exports.Broadcast = undefined;

	var _Broadcast2 = __webpack_require__(15);

	var _Broadcast3 = _interopRequireDefault(_Broadcast2);

	var _Subscriber2 = __webpack_require__(17);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.Broadcast = _Broadcast3.default;
	exports.Subscriber = _Subscriber3.default;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _invariant = __webpack_require__(16);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var createBroadcast = function createBroadcast(initialValue) {
	  var listeners = [];
	  var currentValue = initialValue;

	  return {
	    publish: function publish(value) {
	      currentValue = value;
	      listeners.forEach(function (listener) {
	        return listener(currentValue);
	      });
	    },
	    subscribe: function subscribe(listener) {
	      listeners.push(listener);

	      // Publish to this subscriber once immediately.
	      listener(currentValue);

	      return function () {
	        return listeners = listeners.filter(function (item) {
	          return item !== listener;
	        });
	      };
	    }
	  };
	};

	/**
	 * A <Broadcast> provides a generic way for descendants to "subscribe"
	 * to some value that changes over time, bypassing any intermediate
	 * shouldComponentUpdate's in the hierarchy. It puts all subscription
	 * functions on context.broadcasts, keyed by "channel".
	 *
	 * To use it, a subscriber must opt-in to context.broadcasts. See the
	 * <Subscriber> component for a reference implementation.
	 */

	var Broadcast = function (_React$Component) {
	  _inherits(Broadcast, _React$Component);

	  function Broadcast() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, Broadcast);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.broadcast = createBroadcast(_this.props.value), _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  Broadcast.prototype.getBroadcastsContext = function getBroadcastsContext() {
	    var _extends2;

	    var channel = this.props.channel;
	    var broadcasts = this.context.broadcasts;


	    return _extends({}, broadcasts, (_extends2 = {}, _extends2[channel] = this.broadcast.subscribe, _extends2));
	  };

	  Broadcast.prototype.getChildContext = function getChildContext() {
	    return {
	      broadcasts: this.getBroadcastsContext()
	    };
	  };

	  Broadcast.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    !(this.props.channel === nextProps.channel) ?  false ? (0, _invariant2.default)(false, 'You cannot change <Broadcast channel>') : (0, _invariant2.default)(false) : void 0;

	    if (this.props.value !== nextProps.value) this.broadcast.publish(nextProps.value);
	  };

	  Broadcast.prototype.render = function render() {
	    return _react2.default.Children.only(this.props.children);
	  };

	  return Broadcast;
	}(_react2.default.Component);

	Broadcast.contextTypes = {
	  broadcasts: _react.PropTypes.object
	};
	Broadcast.childContextTypes = {
	  broadcasts: _react.PropTypes.object.isRequired
	};


	if (false) {
	  Broadcast.propTypes = {
	    channel: _react.PropTypes.string.isRequired,
	    children: _react.PropTypes.node.isRequired,
	    value: _react.PropTypes.any
	  };
	}

	exports.default = Broadcast;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (false) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};

	module.exports = invariant;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _invariant = __webpack_require__(16);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A <Subscriber> pulls the value for a channel off of context.broadcasts
	 * and passes it to its children function.
	 */
	var Subscriber = function (_React$Component) {
	  _inherits(Subscriber, _React$Component);

	  function Subscriber() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, Subscriber);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
	      value: null
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  Subscriber.prototype.componentWillMount = function componentWillMount() {
	    var _this2 = this;

	    var channel = this.props.channel;


	    if (this.context.broadcasts) {
	      var subscribe = this.context.broadcasts[channel];

	      !(typeof subscribe === 'function') ?  false ? (0, _invariant2.default)(false, '<Subscriber channel="%s"> must be rendered in the context of a <Broadcast channel="%s">', channel, channel) : (0, _invariant2.default)(false) : void 0;

	      this.unsubscribe = subscribe(function (value) {
	        // This function will be called once immediately.
	        _this2.setState({ value: value });
	      });
	    }
	  };

	  Subscriber.prototype.componentWillUnmount = function componentWillUnmount() {
	    this.unsubscribe();
	  };

	  Subscriber.prototype.render = function render() {
	    return this.props.children(this.state.value);
	  };

	  return Subscriber;
	}(_react2.default.Component);

	Subscriber.contextTypes = {
	  broadcasts: _react2.default.PropTypes.object
	};


	if (false) {
	  Subscriber.propTypes = {
	    channel: _react.PropTypes.string.isRequired,
	    children: _react.PropTypes.func.isRequired
	  };
	}

	exports.default = Subscriber;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.createRouterPath = exports.createRouterLocation = exports.locationsAreEqual = undefined;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _LocationUtils = __webpack_require__(3);

	Object.defineProperty(exports, 'locationsAreEqual', {
	  enumerable: true,
	  get: function get() {
	    return _LocationUtils.locationsAreEqual;
	  }
	});

	var _PathUtils = __webpack_require__(5);

	var createRouterLocation = exports.createRouterLocation = function createRouterLocation(input, parseQueryString, stringifyQuery) {
	  if (typeof input === 'string') {
	    var location = (0, _PathUtils.parsePath)(input);
	    location.query = location.search !== '' ? parseQueryString(location.search) : null;
	    return location;
	  } else {
	    // got a location descriptor
	    return {
	      pathname: input.pathname || '',
	      search: input.search || (input.query ? '?' + stringifyQuery(input.query) : ''),
	      hash: input.hash || '',
	      state: input.state || null,
	      query: input.query || (input.search ? parseQueryString(input.search) : null)
	    };
	  }
	};

	var createRouterPath = exports.createRouterPath = function createRouterPath(input, stringifyQuery) {
	  return typeof input === 'string' ? input : (0, _PathUtils.createPath)(_extends({}, input, {
	    search: input.search || (input.query ? '?' + stringifyQuery(input.query) : '')
	  }));
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _ControlledHistory = __webpack_require__(1);

	var _ControlledHistory2 = _interopRequireDefault(_ControlledHistory);

	var _StaticRouter = __webpack_require__(7);

	var _StaticRouter2 = _interopRequireDefault(_StaticRouter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	var ControlledMemoryRouter = function ControlledMemoryRouter(_ref) {
	  var history = _ref.history;
	  var location = _ref.location;
	  var action = _ref.action;
	  var onChange = _ref.onChange;
	  var restoreKeys = _ref.restoreKeys;
	  var saveKeys = _ref.saveKeys;

	  var routerProps = _objectWithoutProperties(_ref, ['history', 'location', 'action', 'onChange', 'restoreKeys', 'saveKeys']);

	  return _react2.default.createElement(
	    _ControlledHistory2.default,
	    {
	      history: history,
	      location: location,
	      action: action,
	      onChange: onChange,
	      restoreKeys: restoreKeys,
	      saveKeys: saveKeys
	    },
	    function (_ref2) {
	      var history = _ref2.history;
	      var action = _ref2.action;
	      var location = _ref2.location;
	      return _react2.default.createElement(_StaticRouter2.default, _extends({
	        action: action,
	        location: location,
	        onPush: history.push,
	        onReplace: history.replace,
	        blockTransitions: history.block
	      }, routerProps));
	    }
	  );
	};

	ControlledMemoryRouter.propTypes = {
	  // controlled props
	  history: _react.PropTypes.object,
	  location: _react.PropTypes.object,
	  action: _react.PropTypes.string,
	  onChange: _react.PropTypes.func,
	  restoreKeys: _react.PropTypes.func,
	  saveKeys: _react.PropTypes.func,

	  // history options
	  getUserConfirmation: _react.PropTypes.func,
	  initialEntries: _react.PropTypes.array,
	  initialIndex: _react.PropTypes.number,
	  keyLength: _react.PropTypes.number,

	  // router options
	  children: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.node])
	};

	exports.default = ControlledMemoryRouter;

/***/ }
/******/ ])
});
;