(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["ReactHistory"] = factory(require("react"));
	else
		root["ReactHistory"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.ControlledHistory = undefined;

	var _ControlledHistory2 = __webpack_require__(1);

	var _ControlledHistory3 = _interopRequireDefault(_ControlledHistory2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.ControlledHistory = _ControlledHistory3.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _LocationUtils = __webpack_require__(3);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var initialKeys = [undefined];

	var ControlledHistory = function (_React$Component) {
	  _inherits(ControlledHistory, _React$Component);

	  ControlledHistory.prototype.getChildContext = function getChildContext() {
	    return {
	      history: this.props.history
	    };
	  };

	  function ControlledHistory(props) {
	    _classCallCheck(this, ControlledHistory);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    var location = props.history.location;
	    var shouldRestoreKeys = !!location.key;
	    _this.updatingFromHistoryChange = false;
	    _this.syncingHistory = false;
	    _this.keys = shouldRestoreKeys ? props.restoreKeys() : initialKeys;
	    _this.setupHistory();
	    _this.state = {
	      location: location,
	      action: 'POP'
	    };
	    return _this;
	  }

	  ControlledHistory.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    if (!this.syncingHistory && !this.updatingFromHistoryChange && !(0, _LocationUtils.locationsAreEqual)(nextProps.location, this.props.location)) {
	      this.syncingHistory = true;
	      var history = this.props.history;
	      var action = nextProps.action;
	      var location = nextProps.location;

	      var nextIndex = this.keys.indexOf(location.key);
	      if (location.key && nextIndex !== -1) {
	        // we've been here before
	        var currentIndex = this.keys.indexOf(this.props.location.key);
	        var delta = nextIndex - currentIndex;
	        history.go(delta);
	      } else if (action === 'PUSH') {
	        history.push(location);
	      } else if (action === 'REPLACE') {
	        history.replace(location);
	      }
	    }
	  };

	  ControlledHistory.prototype.setupHistory = function setupHistory() {
	    var _this2 = this;

	    this.props.history.listen(function (location, action) {
	      _this2.storeKey(location.key, action);
	      _this2.updatingFromHistoryChange = true; // must come before onChange!
	      if (_this2.syncingHistory) {
	        _this2.props.onChange(location, 'SYNC');
	      } else {
	        _this2.props.onChange(location, action);
	      }
	      _this2.setState({ location: location, action: action }, function () {
	        _this2.updatingFromHistoryChange = false;
	        if (_this2.syncingHistory) {
	          _this2.syncingHistory = false;
	        } else {
	          _this2.checkIfLocationAccepted();
	        }
	      });
	    });
	  };

	  ControlledHistory.prototype.checkIfLocationAccepted = function checkIfLocationAccepted() {
	    var location = this.props.location;
	    var _state = this.state;
	    var stateLocation = _state.location;
	    var stateAction = _state.action;

	    if (!(0, _LocationUtils.locationsAreEqual)(location, stateLocation)) {
	      this.syncingHistory = true;
	      var index = this.keys.indexOf(location.key);
	      var stateIndex = this.keys.indexOf(stateLocation.key);
	      var delta = index - stateIndex;
	      if (stateAction === 'REPLACE') {
	        this.props.history.replace(location);
	      } else {
	        if (stateIndex === -1) {
	          // playing whack-a-mole here D: after we pop off the last key a
	          // few lines down, if they click "forward" we won't find the key
	          // so let's just do a -1 for delta.
	          this.props.history.go(-1);
	        } else {
	          this.props.history.go(delta);
	        }
	        if (stateAction === 'PUSH') {
	          // get rid of the last entry so our delta isn't off if they try to
	          // push here again
	          this.keys.pop();
	        }
	      }
	    }
	  };

	  ControlledHistory.prototype.storeKey = function storeKey(key, action) {
	    if (action === 'PUSH') {
	      this.keys.push(key);
	    } else if (action === 'REPLACE') {
	      this.keys[this.keys.length - 1] = key;
	    }
	    // browsers only keep 50 entries, so we'll do that too
	    if (this.keys.length > 50) this.keys.unshift();
	    this.props.saveKeys(this.keys);
	  };

	  ControlledHistory.prototype.render = function render() {
	    var _props = this.props;
	    var history = _props.history;
	    var location = _props.location;
	    var action = _props.action;

	    return this.props.children({
	      history: history,
	      location: location,
	      action: action
	    });
	  };

	  return ControlledHistory;
	}(_react2.default.Component);

	ControlledHistory.propTypes = {
	  children: _react.PropTypes.func.isRequired,
	  history: _react.PropTypes.object.isRequired,
	  location: _react.PropTypes.object.isRequired,
	  action: _react.PropTypes.string.isRequired,
	  onChange: _react.PropTypes.func.isRequired,
	  restoreKeys: _react.PropTypes.func.isRequired,
	  saveKeys: _react.PropTypes.func.isRequired
	};
	ControlledHistory.childContextTypes = {
	  history: _react.PropTypes.object.isRequired
	};
	ControlledHistory.defaultProps = {
	  restoreKeys: function restoreKeys() {
	    return initialKeys;
	  },
	  saveKeys: function saveKeys() {}
	};
	exports.default = ControlledHistory;

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.locationsAreEqual = exports.createLocation = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _resolvePathname = __webpack_require__(4);

	var _resolvePathname2 = _interopRequireDefault(_resolvePathname);

	var _PathUtils = __webpack_require__(5);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {
	  var location = void 0;
	  if (typeof path === 'string') {
	    // Two-arg form: push(path, state)
	    location = (0, _PathUtils.parsePath)(path);
	    location.state = state;
	  } else {
	    // One-arg form: push(location)
	    location = _extends({}, path);

	    if (location.pathname === undefined) location.pathname = '';

	    if (location.search) {
	      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
	    } else {
	      location.search = '';
	    }

	    if (location.hash) {
	      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
	    } else {
	      location.hash = '';
	    }

	    if (state !== undefined && location.state === undefined) location.state = state;
	  }

	  location.key = key;

	  if (currentLocation) {
	    // Resolve incomplete/relative pathname relative to current location.
	    if (!location.pathname) {
	      location.pathname = currentLocation.pathname;
	    } else if (location.pathname.charAt(0) !== '/') {
	      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
	    }
	  }

	  return location;
	};

	var looseEqual = function looseEqual(a, b) {
	  if (a == null) return a == b;

	  var typeofA = typeof a === 'undefined' ? 'undefined' : _typeof(a);
	  var typeofB = typeof b === 'undefined' ? 'undefined' : _typeof(b);

	  if (typeofA !== typeofB) return false;

	  if (Array.isArray(a)) {
	    if (!Array.isArray(b) || a.length !== b.length) return false;

	    return a.every(function (item, index) {
	      return looseEqual(item, b[index]);
	    });
	  } else if (typeofA === 'object') {
	    var aKeys = Object.keys(a);
	    var bKeys = Object.keys(b);

	    if (aKeys.length !== bKeys.length) return false;

	    return aKeys.every(function (key) {
	      return looseEqual(a[key], b[key]);
	    });
	  }

	  return a === b;
	};

	var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
	  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && looseEqual(a.state, b.state);
	};

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';

	var isAbsolute = function isAbsolute(pathname) {
	  return pathname.charAt(0) === '/';
	};

	// About 1.5x faster than the two-arg version of Array#splice()
	var spliceOne = function spliceOne(list, index) {
	  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
	    list[i] = list[k];
	  }list.pop();
	};

	// This implementation is based heavily on node's url.parse
	var resolvePathname = function resolvePathname(to) {
	  var from = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	  var toParts = to && to.split('/') || [];
	  var fromParts = from && from.split('/') || [];

	  var isToAbs = to && isAbsolute(to);
	  var isFromAbs = from && isAbsolute(from);
	  var mustEndAbs = isToAbs || isFromAbs;

	  if (to && isAbsolute(to)) {
	    // to is absolute
	    fromParts = toParts;
	  } else if (toParts.length) {
	    // to is relative, drop the filename
	    fromParts.pop();
	    fromParts = fromParts.concat(toParts);
	  }

	  if (!fromParts.length) return '/';

	  var hasTrailingSlash = void 0;
	  if (fromParts.length) {
	    var last = fromParts[fromParts.length - 1];
	    hasTrailingSlash = last === '.' || last === '..' || last === '';
	  } else {
	    hasTrailingSlash = false;
	  }

	  var up = 0;
	  for (var i = fromParts.length; i >= 0; i--) {
	    var part = fromParts[i];

	    if (part === '.') {
	      spliceOne(fromParts, i);
	    } else if (part === '..') {
	      spliceOne(fromParts, i);
	      up++;
	    } else if (up) {
	      spliceOne(fromParts, i);
	      up--;
	    }
	  }

	  if (!mustEndAbs) for (; up--; up) {
	    fromParts.unshift('..');
	  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

	  var result = fromParts.join('/');

	  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

	  return result;
	};

	module.exports = resolvePathname;

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	var addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {
	  return path.charAt(0) === '/' ? path : '/' + path;
	};

	var stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {
	  return path.charAt(0) === '/' ? path.substr(1) : path;
	};

	var stripPrefix = exports.stripPrefix = function stripPrefix(path, prefix) {
	  return path.indexOf(prefix) === 0 ? path.substr(prefix.length) : path;
	};

	var parsePath = exports.parsePath = function parsePath(path) {
	  var pathname = path || '/';
	  var search = '';
	  var hash = '';

	  var hashIndex = pathname.indexOf('#');
	  if (hashIndex !== -1) {
	    hash = pathname.substr(hashIndex);
	    pathname = pathname.substr(0, hashIndex);
	  }

	  var searchIndex = pathname.indexOf('?');
	  if (searchIndex !== -1) {
	    search = pathname.substr(searchIndex);
	    pathname = pathname.substr(0, searchIndex);
	  }

	  return {
	    pathname: pathname,
	    search: search === '?' ? '' : search,
	    hash: hash === '#' ? '' : hash
	  };
	};

	var createPath = exports.createPath = function createPath(location) {
	  var pathname = location.pathname;
	  var search = location.search;
	  var hash = location.hash;


	  var path = pathname || '/';

	  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

	  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

	  return path;
	};

/***/ }
/******/ ])
});
;